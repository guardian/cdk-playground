{"version":3,"file":"BrazeMessaging-importable.client.web.87e3ecb6eeaa78977a01.js","mappings":"mNAoBO,MAAMA,EAAkB,I,IAAA,SAAEC,GAAiB,EACjD,MAAM,gBAAEC,IAAoBC,EAAAA,EAAAA,MAEtB,cAAEC,EAAa,WAAEC,IAAeC,EAAAA,EAAAA,GAASL,EAAUC,GAUzD,OARIE,IACHG,EAAAA,EAAAA,IAAI,KAAM,kCAAmCH,GAE1CC,IACHE,EAAAA,EAAAA,IAAI,KAAM,+BAAgCF,GAIpC,IAAI,C,0DCfZ,SAASG,EAAeC,GACvB,IAAKA,EAASC,GACb,MAAMC,MACLF,EAASG,YACR,uDAAuE,OAAhBH,EAASI,SAGnE,OAAOJ,CACR,CAEA,MAAMK,EAAWC,GACTC,MAAMD,EAAK,CACjBE,YAAa,YAEZC,KAAKV,GACLU,MAAMT,GAAaA,EAASU,SAGzBC,EAGF,CAAC,EAEQC,EAAoBC,IAChC,IAAKF,EAAMG,oBAAqB,CAC/B,MAAMR,GAAMS,EAAAA,EAAAA,GAAQF,EAAS,WAC7BF,EAAMG,oBAAsBT,EAAQC,EACrC,CACA,OAAOK,EAAMG,mBAAmB,EAGpBE,EACZH,IAEA,IAAKF,EAAMM,6BAA8B,CACxC,MAAMX,GAAMS,EAAAA,EAAAA,GAAQF,EAAS,uBAC7BF,EAAMM,6BAA+BZ,EAAQC,EAC9C,CACA,OAAOK,EAAMM,4BAA4B,C,qEC3CnC,MAAMC,EAAgB,KAE5B,OADmBC,IACAC,MAClB,IAAK,UACJ,MAAO,UACR,IAAK,sBACL,IAAK,mBACJ,OAAO,EACR,IAAK,uBACL,IAAK,oBACJ,OAAO,EACT,EAGYD,EAAgB,KAC5B,MAAOE,EAAYC,IAAiBC,EAAAA,EAAAA,UAAqB,CACxDH,KAAM,YAcP,OAXAI,EAAAA,EAAAA,YAAU,MACTC,EAAAA,EAAAA,KACEC,IACAJ,GAAcK,EAAAA,EAAAA,IAA0BD,GAAe,IAExD,IAAMJ,GAAcM,EAAAA,EAAAA,SACnBC,OAAOC,IACRC,QAAQD,MAAMA,EAAM,GACnB,GACA,IAEIT,CAAU,C,wGCzClB,MAAMW,EAAM,kB,0BCEL,MAAMC,EAAeC,MAAOrB,IAElCY,EAAAA,EAAAA,KACEU,I,IAAcA,E,OAAiB,QAAjBA,EAAAA,EAAUC,eAAVD,IAAAA,OAAAA,EAAAA,EAAmBE,OAAOC,UAAU,IACnD,KACCtB,EAAAA,EAAAA,GAAwBH,GACtBJ,MAAM8B,GAA+BA,EAAKC,YAC1CX,OAAOC,IACPW,OAAOC,SAASC,QAAQC,OAAOC,YAC9Bf,EACA,qB,cCZN,MCuBMgB,EAAuB,CAACC,EAAcC,EAAYT,KAAsB,CAC7EU,cAAc,EACdC,QAAS,CACRC,MAAOJ,EACPR,KAAMS,GAEPT,S,cC5BD,MAAMa,EAA4C,CACjDC,eAAe,EACfC,WAAW,EACXC,QAAS,qCACTC,wBAAyB,EACzBC,8CAA+C,EAC/CC,wBAAyB,IAcpBC,EAAuB,MAC5B,IAAIhD,EAEJ,OAAQiD,KACHC,EAAAA,EAAAA,GAAYlD,KACfA,EAhBsBuB,OAAO0B,IAC/B,MAAME,QAAwB,qCAO9B,OAHAA,EAAeC,WAAWC,IAAYlE,EAAAA,EAAAA,IAAI,KAAMkE,KAChDF,EAAeG,WAAWL,EAAQR,GAE3BU,CAAc,EAQXI,CAAiBN,IAGnBjD,EAER,EAV4B,GC6BhBwD,EAAsBjC,MAClC1C,EACA4E,EACA3E,KAKA,IAAK4E,EAAAA,EAAQC,MAAMC,cAGlB,MAAO,CACN5E,cAAe,IAAI6E,EAAAA,GACnB5E,WAAY,IAAI6E,EAAAA,IAIlB,MAAMC,OFPwBxC,OAC9BkC,EACA5E,KAEA,MAAMmF,EAhCmB,EACzBP,EACA5E,IAEO,CACN,CACCuD,KAAM,SACNC,MAAO4B,QAAQC,QAAQpC,OAAOC,SAASoC,OAAOC,KAAKC,cAEpD,CACCjC,KAAM,cACNC,MAAO4B,QAAQC,QAAQpC,OAAOC,SAASoC,OAAOG,SAASC,cAExD,CACCnC,KAAM,YACNC,MAAOoB,EAAanC,EAAazC,GAAYoF,QAAQC,QAAQ,OAE9D,CACC9B,KAAM,UACNC,MDlDF,IAAI4B,SAAQ,CAACC,EAASM,MACrBC,EAAAA,EAAAA,KAAiBC,IAChB,IACCR,GAAQS,EAAAA,EAAAA,IAAc,QAASD,GAChC,CAAE,MAAOE,GACRJ,EAAOI,EACR,IACC,KC6CF,CACCxC,KAAM,mBACNC,MAAO4B,QAAQC,SAASpC,OAAOC,SAASoC,OAAOC,KAAKS,iBASjCC,CAAkBrB,EAAY5E,GAE7C+C,EAAmB,CAAC,EAK1B,IAAK,MAAM,KAAEQ,EAAI,MAAEC,KAAW2B,EAC7B,IACC,MAAMe,QAAe1C,EAGrB,IAAI0C,EAGH,OAAO5C,EAAqBC,EAAM2C,EAAQnD,GAF1CA,EAAKQ,GAAQ2C,CAIf,CAAE,MAAOH,GACR,OAAOzC,EACNC,EACAwC,aAAarF,MAAQqF,EAAEvB,QAAUuB,EACjChD,EAEF,CAGD,MAAO,CACNU,cAAc,EACdV,OACA,EE1BgCoD,CAChCvB,EACA5E,GAGD,IAAKkF,EAAmBzB,aAAc,CACrC,MAAM,QAAEC,EAAO,KAAEX,GAASmC,EAgB1B,OAdA5E,EAAAA,EAAAA,IACC,KACA,qDAEgB8F,OADf1C,EAAQC,MACR,iBAAoC,OAArByC,OAAO1C,EAAQX,MAAM,WA1DdL,OACzB0B,EACApB,EACAqD,EACAX,KAEA,MAAMY,ELxB+B,SAA9BzB,EAAAA,EAAQC,MAAMyB,OAAO/D,GK6B5B,IAJ0BQ,GAAasD,IACRD,GAAWC,IACZZ,GAAeY,EAG5C,IACKlC,UACkBD,EAAqBC,IACnCoC,WAERC,EAAAA,GAAkBC,QL3BpB7B,EAAAA,EAAQC,MAAM6B,OAAOnE,EK6BpB,CAAE,MAAOF,GACRW,OAAOC,SAASC,QAAQC,OAAOC,YAE9Bf,EACA,0BAEF,CACD,EAmCOsE,CACL7D,EAAKqB,OACLrB,EAAKC,UACLD,EAAKsD,QACLtD,EAAK2C,aAGC,CACNvF,cAAe,IAAI6E,EAAAA,GACnB5E,WAAY,IAAI6E,EAAAA,GAElB,CAEA,IACC,MAAM,sBAAE4B,IAA0BC,EAAAA,EAAAA,GACjC,KACA,kBAGKC,QAAe5C,EACpBe,EAAmBnC,KAAKqB,QAGnB4C,EAAmBH,WACLI,EAAAA,EAAAA,IAAShH,IACvBiH,OAAO,CAGZC,UAAW,wBACX3D,MAAOwD,IAGR,MAAMI,EAAe,CAAC9E,EAAc+E,KACnCpE,OAAOC,SAASC,QAAQC,OAAOC,YAAYf,EAAO+E,EAAK,EL5GzDxC,EAAAA,EAAQC,MAAMwC,OAAO9E,EAAK,QKgHzBuE,EAAOQ,WAAWrC,EAAmBnC,KAAKC,WAC1C+D,EAAOS,cAEP,MAAMpH,EAAa6C,OAAOC,SAASoC,OAAOG,SAASgC,kBAChD,IAAIC,EAAAA,GAAWX,EAAQK,GACvB,IAAInC,EAAAA,GAOP,MAAO,CAAE9E,cANa,IAAIwH,EAAAA,GACzBZ,EACAN,EAAAA,GACAW,EACAQ,EAAAA,IAEuBxH,aACzB,CAAE,SACD,MAAO,CACND,cAAe,IAAI6E,EAAAA,GACnB5E,WAAY,IAAI6E,EAAAA,GAElB,G,eCrHM,MAAM5E,EAAW,CACvBL,EACAC,KAKA,MAAM4B,GAAaF,EAAAA,EAAAA,KACbiD,EACe,qBAApB/C,EAAWD,MACS,wBAApBC,EAAWD,MAEN,KAAEmB,EAAI,MAAET,IAAUuF,EAAAA,EAAAA,GACH,YAApBhG,EAAWD,KAAqB,gBAAkB,MAClD,IAAM+C,EAAoB3E,EAAU4E,EAAY3E,KAGjD,OAAIqC,EACI,CACNnC,cAAe,IAAI6E,EAAAA,GACnB5E,WAAY,IAAI6E,EAAAA,IAIX,CACN9E,cAAe4C,aAAAA,EAAAA,EAAM5C,cACrBC,WAAY2C,aAAAA,EAAAA,EAAM3C,WAClB,C","sources":["webpack://@guardian/dotcom-rendering/./src/components/BrazeMessaging.importable.tsx","webpack://@guardian/dotcom-rendering/./src/lib/getIdapiUserData.ts","webpack://@guardian/dotcom-rendering/./src/lib/useAuthStatus.ts","webpack://@guardian/dotcom-rendering/./src/lib/hasCurrentBrazeUser.ts","webpack://@guardian/dotcom-rendering/./src/lib/getBrazeUuid.ts","webpack://@guardian/dotcom-rendering/./src/lib/braze/hasRequiredConsents.ts","webpack://@guardian/dotcom-rendering/./src/lib/braze/checkBrazeDependencies.ts","webpack://@guardian/dotcom-rendering/./src/lib/braze/initialiseAppboy.ts","webpack://@guardian/dotcom-rendering/./src/lib/braze/buildBrazeMessaging.ts","webpack://@guardian/dotcom-rendering/./src/lib/useBraze.ts"],"sourcesContent":["import { log } from '@guardian/libs';\nimport { useBraze } from '../lib/useBraze';\nimport { useConfig } from './ConfigContext';\n\ntype Props = {\n\tidApiUrl: string;\n};\n\n/**\n * This component ensures we call buildBrazeMessaging at least once\n * on every page\n *\n * ## Why does this need to be an Island?\n *\n * All behaviour is client-side.\n *\n * ---\n *\n * Does not render **anything**.\n */\nexport const BrazeMessaging = ({ idApiUrl }: Props) => {\n\tconst { renderingTarget } = useConfig();\n\n\tconst { brazeMessages, brazeCards } = useBraze(idApiUrl, renderingTarget);\n\n\tif (brazeMessages) {\n\t\tlog('tx', 'Braze Messages Interface loaded', brazeMessages);\n\t}\n\tif (brazeCards) {\n\t\tlog('tx', 'Braze Cards Interface loaded', brazeCards);\n\t}\n\n\t// we donâ€™t render anything\n\treturn null;\n};\n","import { joinUrl } from '@guardian/libs';\n\nexport interface IdApiUserData {\n\tuser?: {\n\t\tprimaryEmailAddress?: string;\n\t\tprivateFields?: {\n\t\t\tbrazeUuid?: string;\n\t\t};\n\t};\n}\n\nexport interface IdApiUserIdentifiers {\n\tid: string;\n\tbrazeUuid: string;\n\tpuzzleId: string;\n\tgoogleTagId: string;\n}\n\nfunction checkForErrors(response: Response) {\n\tif (!response.ok) {\n\t\tthrow Error(\n\t\t\tresponse.statusText ||\n\t\t\t\t`getIdApiUserData | An api call returned HTTP status ${response.status}`,\n\t\t);\n\t}\n\treturn response;\n}\n\nconst callApi = (url: string) => {\n\treturn fetch(url, {\n\t\tcredentials: 'include',\n\t})\n\t\t.then(checkForErrors)\n\t\t.then((response) => response.json());\n};\n\nconst cache: {\n\tidapiUserMeResponse?: Promise<IdApiUserData>;\n\tidapiUserIdentifiersResponse?: Promise<IdApiUserIdentifiers>;\n} = {};\n\nexport const getIdApiUserData = (ajaxUrl: string): Promise<IdApiUserData> => {\n\tif (!cache.idapiUserMeResponse) {\n\t\tconst url = joinUrl(ajaxUrl, 'user/me');\n\t\tcache.idapiUserMeResponse = callApi(url);\n\t}\n\treturn cache.idapiUserMeResponse;\n};\n\nexport const getIdapiUserIdentifiers = (\n\tajaxUrl: string,\n): Promise<IdApiUserIdentifiers> => {\n\tif (!cache.idapiUserIdentifiersResponse) {\n\t\tconst url = joinUrl(ajaxUrl, 'user/me/identifiers');\n\t\tcache.idapiUserIdentifiersResponse = callApi(url);\n\t}\n\treturn cache.idapiUserIdentifiersResponse;\n};\n","import { useEffect, useState } from 'react';\nimport type { AuthStatus } from './identity';\nimport {\n\teitherInOktaTestOrElse,\n\tgetSignedInStatusWithCookies,\n\tgetSignedInStatusWithOkta,\n} from './identity';\n\n/**\n * A hook to find out if a user is signed in.\n * Returns `'Pending'` until status is known.\n * Always returns `'Pending'` during server-side rendering.\n * */\nexport const useIsSignedIn = (): boolean | 'Pending' => {\n\tconst authStatus = useAuthStatus();\n\tswitch (authStatus.kind) {\n\t\tcase 'Pending':\n\t\t\treturn 'Pending';\n\t\tcase 'SignedInWithCookies':\n\t\tcase 'SignedInWithOkta':\n\t\t\treturn true;\n\t\tcase 'SignedOutWithCookies':\n\t\tcase 'SignedOutWithOkta':\n\t\t\treturn false;\n\t}\n};\n\nexport const useAuthStatus = (): AuthStatus => {\n\tconst [authStatus, setAuthStatus] = useState<AuthStatus>({\n\t\tkind: 'Pending',\n\t});\n\n\tuseEffect(() => {\n\t\teitherInOktaTestOrElse(\n\t\t\t(oktaAuthState) => {\n\t\t\t\tsetAuthStatus(getSignedInStatusWithOkta(oktaAuthState));\n\t\t\t},\n\t\t\t() => setAuthStatus(getSignedInStatusWithCookies()),\n\t\t).catch((error) => {\n\t\t\tconsole.error(error);\n\t\t});\n\t}, []);\n\n\treturn authStatus;\n};\n","import { storage } from '@guardian/libs';\n\nconst KEY = 'gu.brazeUserSet';\n\nconst hasCurrentBrazeUser = (): boolean => {\n\treturn storage.local.getRaw(KEY) === 'true';\n};\n\nconst setHasCurrentBrazeUser = (): void => {\n\tstorage.local.setRaw(KEY, 'true');\n};\n\nconst clearHasCurrentBrazeUser = (): void => {\n\tstorage.local.remove(KEY);\n};\n\nexport {\n\thasCurrentBrazeUser,\n\tsetHasCurrentBrazeUser,\n\tclearHasCurrentBrazeUser,\n};\n","import type { IdApiUserIdentifiers } from './getIdapiUserData';\nimport { getIdapiUserIdentifiers } from './getIdapiUserData';\nimport { eitherInOktaTestOrElse } from './identity';\n\nexport const getBrazeUuid = async (ajaxUrl: string): Promise<string | void> =>\n\t// TODO Okta: Remove either when at 100% in oktaVariant test, and just use idToken\n\teitherInOktaTestOrElse(\n\t\t(authState) => authState.idToken?.claims.braze_uuid,\n\t\t() =>\n\t\t\tgetIdapiUserIdentifiers(ajaxUrl)\n\t\t\t\t.then((data: IdApiUserIdentifiers) => data.brazeUuid)\n\t\t\t\t.catch((error) => {\n\t\t\t\t\twindow.guardian.modules.sentry.reportError(\n\t\t\t\t\t\terror,\n\t\t\t\t\t\t'getBrazeUuid',\n\t\t\t\t\t);\n\t\t\t\t}),\n\t);\n","import { getConsentFor, onConsentChange } from '@guardian/libs';\n\nconst hasRequiredConsents = (): Promise<boolean> =>\n\tnew Promise((resolve, reject) => {\n\t\tonConsentChange((state) => {\n\t\t\ttry {\n\t\t\t\tresolve(getConsentFor('braze', state));\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t});\n\t});\n\nexport { hasRequiredConsents };\n","import { getBrazeUuid } from '../getBrazeUuid';\nimport { hasRequiredConsents } from './hasRequiredConsents';\n\ntype SuccessResult = {\n\tisSuccessful: true;\n\tdata: ResultData;\n};\n\ntype FailureResult = {\n\tisSuccessful: false;\n\tfailure: {\n\t\tfield: string;\n\t\tdata: any;\n\t};\n\tdata: ResultData;\n};\n\ntype DependenciesResult = SuccessResult | FailureResult;\n\ntype ResultData = { [key: string]: string | boolean };\n\ntype DependencyResult = {\n\tname: string;\n\tvalue: Promise<string | boolean | null | undefined | void>;\n};\nconst buildFailureResponse = (name: string, value: any, data: ResultData) => ({\n\tisSuccessful: false,\n\tfailure: {\n\t\tfield: name,\n\t\tdata: value,\n\t},\n\tdata,\n});\n\nconst buildDependencies = (\n\tisSignedIn: boolean,\n\tidApiUrl: string,\n): DependencyResult[] => {\n\treturn [\n\t\t{\n\t\t\tname: 'apiKey',\n\t\t\tvalue: Promise.resolve(window.guardian.config.page.brazeApiKey),\n\t\t},\n\t\t{\n\t\t\tname: 'brazeSwitch',\n\t\t\tvalue: Promise.resolve(window.guardian.config.switches.brazeSwitch),\n\t\t},\n\t\t{\n\t\t\tname: 'brazeUuid',\n\t\t\tvalue: isSignedIn ? getBrazeUuid(idApiUrl) : Promise.resolve(null),\n\t\t},\n\t\t{\n\t\t\tname: 'consent',\n\t\t\tvalue: hasRequiredConsents(),\n\t\t},\n\t\t{\n\t\t\tname: 'isNotPaidContent',\n\t\t\tvalue: Promise.resolve(!window.guardian.config.page.isPaidContent),\n\t\t},\n\t];\n};\n\nconst checkBrazeDependencies = async (\n\tisSignedIn: boolean,\n\tidApiUrl: string,\n): Promise<DependenciesResult> => {\n\tconst dependencies = buildDependencies(isSignedIn, idApiUrl);\n\n\tconst data: ResultData = {};\n\n\t// I think we could possibly clean this up a bit when we can use\n\t// Promise.allSettled reliably (it's not available in our current Node\n\t// version and polyfill.io doesn't have a polyfill yet).\n\tfor (const { name, value } of dependencies) {\n\t\ttry {\n\t\t\tconst result = await value;\n\n\t\t\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- TODO: Complex types, look into this further\n\t\t\tif (result) {\n\t\t\t\tdata[name] = result;\n\t\t\t} else {\n\t\t\t\treturn buildFailureResponse(name, result, data);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn buildFailureResponse(\n\t\t\t\tname,\n\t\t\t\te instanceof Error ? e.message : e,\n\t\t\t\tdata,\n\t\t\t);\n\t\t}\n\t}\n\n\treturn {\n\t\tisSuccessful: true,\n\t\tdata,\n\t};\n};\n\nexport { checkBrazeDependencies };\n","import type appboy from '@braze/web-sdk-core';\nimport { isUndefined, log } from '@guardian/libs';\n\nconst SDK_OPTIONS: appboy.InitializationOptions = {\n\tenableLogging: true,\n\tnoCookies: true,\n\tbaseUrl: 'https://sdk.fra-01.braze.eu/api/v3',\n\tsessionTimeoutInSeconds: 1,\n\tminimumIntervalBetweenTriggerActionsInSeconds: 0,\n\tdevicePropertyAllowlist: [],\n};\n\nconst initialiseAppboy = async (apiKey: string): Promise<typeof appboy> => {\n\tconst importedAppboy = (await import(\n\t\t/* webpackChunkName: \"braze-web-sdk-core\" */ '@braze/web-sdk-core'\n\t)) as unknown as typeof appboy;\n\n\timportedAppboy.setLogger((message) => log('tx', message));\n\timportedAppboy.initialize(apiKey, SDK_OPTIONS);\n\n\treturn importedAppboy;\n};\n\nconst getInitialisedAppboy = (() => {\n\tlet cache: Promise<typeof appboy>;\n\n\treturn (apiKey: string): Promise<typeof appboy> => {\n\t\tif (isUndefined(cache)) {\n\t\t\tcache = initialiseAppboy(apiKey);\n\t\t}\n\n\t\treturn cache;\n\t};\n})();\n\nexport { getInitialisedAppboy };\n","import type {\n\tBrazeCardsInterface,\n\tBrazeMessagesInterface,\n} from '@guardian/braze-components/logic';\nimport {\n\tBrazeCards,\n\tBrazeMessages,\n\tcanRenderBrazeMsg,\n\tLocalMessageCache,\n\tNullBrazeCards,\n\tNullBrazeMessages,\n} from '@guardian/braze-components/logic';\nimport { log, startPerformanceMeasure, storage } from '@guardian/libs';\nimport { getOphan } from '../../client/ophan/ophan';\nimport type { RenderingTarget } from '../../types/renderingTarget';\nimport {\n\tclearHasCurrentBrazeUser,\n\thasCurrentBrazeUser,\n\tsetHasCurrentBrazeUser,\n} from '../hasCurrentBrazeUser';\nimport { checkBrazeDependencies } from './checkBrazeDependencies';\nimport { getInitialisedAppboy } from './initialiseAppboy';\n\nconst maybeWipeUserData = async (\n\tapiKey?: string,\n\tbrazeUuid?: null | string,\n\tconsent?: boolean,\n\tbrazeSwitch?: boolean,\n): Promise<void> => {\n\tconst hasCurrentBrazeUserValue = hasCurrentBrazeUser();\n\tconst userHasLoggedOut = !brazeUuid && hasCurrentBrazeUserValue;\n\tconst userHasRemovedConsent = !consent && hasCurrentBrazeUserValue;\n\tconst brazeHasBeenDisabled = !brazeSwitch && hasCurrentBrazeUserValue;\n\n\tif (userHasLoggedOut || userHasRemovedConsent || brazeHasBeenDisabled) {\n\t\ttry {\n\t\t\tif (apiKey) {\n\t\t\t\tconst appboy = await getInitialisedAppboy(apiKey);\n\t\t\t\tappboy.wipeData();\n\t\t\t}\n\t\t\tLocalMessageCache.clear();\n\t\t\tclearHasCurrentBrazeUser();\n\t\t} catch (error) {\n\t\t\twindow.guardian.modules.sentry.reportError(\n\t\t\t\t// @ts-expect-error\n\t\t\t\terror,\n\t\t\t\t'braze-maybeWipeUserData',\n\t\t\t);\n\t\t}\n\t}\n};\n\nexport const buildBrazeMessaging = async (\n\tidApiUrl: string,\n\tisSignedIn: boolean,\n\trenderingTarget: RenderingTarget,\n): Promise<{\n\tbrazeMessages: BrazeMessagesInterface;\n\tbrazeCards: BrazeCardsInterface;\n}> => {\n\tif (!storage.local.isAvailable()) {\n\t\t// we require local storage for using any message channel so that we know\n\t\t// when to clear up user data from the device on logout\n\t\treturn {\n\t\t\tbrazeMessages: new NullBrazeMessages(),\n\t\t\tbrazeCards: new NullBrazeCards(),\n\t\t};\n\t}\n\n\tconst dependenciesResult = await checkBrazeDependencies(\n\t\tisSignedIn,\n\t\tidApiUrl,\n\t);\n\n\tif (!dependenciesResult.isSuccessful) {\n\t\tconst { failure, data } = dependenciesResult;\n\n\t\tlog(\n\t\t\t'tx',\n\t\t\t`Not attempting to show Braze messages. Dependency ${\n\t\t\t\tfailure.field\n\t\t\t} failed with ${String(failure.data)}.`,\n\t\t);\n\n\t\tawait maybeWipeUserData(\n\t\t\tdata.apiKey as string | undefined,\n\t\t\tdata.brazeUuid as string | null | undefined,\n\t\t\tdata.consent as boolean | undefined,\n\t\t\tdata.brazeSwitch as boolean | undefined,\n\t\t);\n\n\t\treturn {\n\t\t\tbrazeMessages: new NullBrazeMessages(),\n\t\t\tbrazeCards: new NullBrazeCards(),\n\t\t};\n\t}\n\n\ttry {\n\t\tconst { endPerformanceMeasure } = startPerformanceMeasure(\n\t\t\t'tx',\n\t\t\t'braze-sdk-load',\n\t\t);\n\n\t\tconst appboy = await getInitialisedAppboy(\n\t\t\tdependenciesResult.data.apiKey as string,\n\t\t);\n\n\t\tconst sdkLoadTimeTaken = endPerformanceMeasure();\n\t\tconst ophan = await getOphan(renderingTarget);\n\t\tophan.record({\n\t\t\t// @ts-expect-error -- the relevant team should remove this call as it is dropped by Ophan\n\t\t\t// see https://github.com/guardian/dotcom-rendering/pull/11438 further context\n\t\t\tcomponent: 'braze-sdk-load-timing',\n\t\t\tvalue: sdkLoadTimeTaken,\n\t\t});\n\n\t\tconst errorHandler = (error: Error, desc: string) => {\n\t\t\twindow.guardian.modules.sentry.reportError(error, desc);\n\t\t};\n\n\t\tsetHasCurrentBrazeUser();\n\t\tappboy.changeUser(dependenciesResult.data.brazeUuid as string);\n\t\tappboy.openSession();\n\n\t\tconst brazeCards = window.guardian.config.switches.brazeContentCards\n\t\t\t? new BrazeCards(appboy, errorHandler)\n\t\t\t: new NullBrazeCards();\n\t\tconst brazeMessages = new BrazeMessages(\n\t\t\tappboy,\n\t\t\tLocalMessageCache,\n\t\t\terrorHandler,\n\t\t\tcanRenderBrazeMsg,\n\t\t);\n\t\treturn { brazeMessages, brazeCards };\n\t} catch {\n\t\treturn {\n\t\t\tbrazeMessages: new NullBrazeMessages(),\n\t\t\tbrazeCards: new NullBrazeCards(),\n\t\t};\n\t}\n};\n","import type {\n\tBrazeCardsInterface,\n\tBrazeMessagesInterface,\n} from '@guardian/braze-components/logic';\nimport {\n\tNullBrazeCards,\n\tNullBrazeMessages,\n} from '@guardian/braze-components/logic';\nimport useSWRImmutable from 'swr/immutable';\nimport type { RenderingTarget } from '../types/renderingTarget';\nimport { buildBrazeMessaging } from './braze/buildBrazeMessaging';\nimport { useAuthStatus } from './useAuthStatus';\n\n/**\n * Returns brazeMessaging as BrazeMessagesInterface and BrazeCardsInterface\n *\n * BrazeMessages is used to show single-impression messages (like ad impressions).\n * In contrast, BrazeCards can provide persistent user notifications.\n *\n * We're using useSWRImmutable to ensure this call is only made once\n * [doc]: https://swr.vercel.app/docs/revalidation#disable-automatic-revalidations\n */\nexport const useBraze = (\n\tidApiUrl: string,\n\trenderingTarget: RenderingTarget,\n): {\n\tbrazeMessages: BrazeMessagesInterface | undefined;\n\tbrazeCards: BrazeCardsInterface | undefined;\n} => {\n\tconst authStatus = useAuthStatus();\n\tconst isSignedIn =\n\t\tauthStatus.kind === 'SignedInWithOkta' ||\n\t\tauthStatus.kind === 'SignedInWithCookies';\n\n\tconst { data, error } = useSWRImmutable(\n\t\tauthStatus.kind !== 'Pending' ? 'braze-message' : null,\n\t\t() => buildBrazeMessaging(idApiUrl, isSignedIn, renderingTarget),\n\t);\n\n\tif (error) {\n\t\treturn {\n\t\t\tbrazeMessages: new NullBrazeMessages(),\n\t\t\tbrazeCards: new NullBrazeCards(),\n\t\t};\n\t}\n\n\treturn {\n\t\tbrazeMessages: data?.brazeMessages,\n\t\tbrazeCards: data?.brazeCards,\n\t};\n};\n"],"names":["BrazeMessaging","idApiUrl","renderingTarget","useConfig","brazeMessages","brazeCards","useBraze","log","checkForErrors","response","ok","Error","statusText","status","callApi","url","fetch","credentials","then","json","cache","getIdApiUserData","ajaxUrl","idapiUserMeResponse","joinUrl","getIdapiUserIdentifiers","idapiUserIdentifiersResponse","useIsSignedIn","useAuthStatus","kind","authStatus","setAuthStatus","useState","useEffect","eitherInOktaTestOrElse","oktaAuthState","getSignedInStatusWithOkta","getSignedInStatusWithCookies","catch","error","console","KEY","getBrazeUuid","async","authState","idToken","claims","braze_uuid","data","brazeUuid","window","guardian","modules","sentry","reportError","buildFailureResponse","name","value","isSuccessful","failure","field","SDK_OPTIONS","enableLogging","noCookies","baseUrl","sessionTimeoutInSeconds","minimumIntervalBetweenTriggerActionsInSeconds","devicePropertyAllowlist","getInitialisedAppboy","apiKey","isUndefined","importedAppboy","setLogger","message","initialize","initialiseAppboy","buildBrazeMessaging","isSignedIn","storage","local","isAvailable","NullBrazeMessages","NullBrazeCards","dependenciesResult","dependencies","Promise","resolve","config","page","brazeApiKey","switches","brazeSwitch","reject","onConsentChange","state","getConsentFor","e","isPaidContent","buildDependencies","result","checkBrazeDependencies","String","consent","hasCurrentBrazeUserValue","getRaw","wipeData","LocalMessageCache","clear","remove","maybeWipeUserData","endPerformanceMeasure","startPerformanceMeasure","appboy","sdkLoadTimeTaken","getOphan","record","component","errorHandler","desc","setRaw","changeUser","openSession","brazeContentCards","BrazeCards","BrazeMessages","canRenderBrazeMsg","useSWRImmutable"],"sourceRoot":""}